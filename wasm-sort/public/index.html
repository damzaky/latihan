<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sortable Table with Web Workers</title>
    <style>
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        th, td {
            border: 1px solid black;
            padding: 8px;
            text-align: left;
            cursor: pointer;
        }
        th {
            background-color: #f4f4f4;
        }
        .controls {
            margin-bottom: 10px;
        }
        .timing {
            margin-top: 10px;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div class="controls">
        <label for="sortAlgorithm">Choose Sorting Algorithm:</label>
        <select id="sortAlgorithm">
            <option value="js">JavaScript Sort</option>
            <option value="quick">Quick Sort</option>
            <option value="worker">Quick Sort with Web Workers</option>
        </select>
    </div>

    <div class="timing" id="sortTime">Sort Time: -</div>

    <table>
        <thead>
            <tr>
                <th onclick="sortTable(0)">Index ðŸ”½</th>
                <th onclick="sortTable(1)">Random Safe Integer ðŸ”½</th>
                <th>Color Combination</th>
            </tr>
        </thead>
        <tbody id="table-body"></tbody>
    </table>

    <script>
        const cssColors = [
            "red", "blue", "green", "yellow", "purple", "orange", "pink", "brown",
            "gray", "black", "white", "cyan", "magenta", "lime", "maroon", "navy",
            "olive", "teal", "silver", "gold", "coral", "violet", "indigo", "turquoise"
        ];

        let sortDirection = [1, 1]; // Stores sorting order (1 for ascending, -1 for descending)
        let masterData = []; // Holds the table data

        function getRandomSafeInteger() {
            return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
        }

        function getRandomColorCombination() {
            const shuffled = cssColors.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 4).join(" ");
        }

        function populateMasterData() {
            masterData = [];
            for (let i = 1; i <= 1000; i++) {
                masterData.push([
                    i,
                    getRandomSafeInteger(),
                    getRandomColorCombination()
                ]);
            }
            renderTable(); // After populating the data, render the table
        }

        function renderTable() {
            const tbody = document.getElementById("table-body");
            tbody.innerHTML = ""; // Clear existing rows
            masterData.forEach(rowData => {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${rowData[0]}</td>
                    <td>${rowData[1]}</td>
                    <td>${rowData[2]}</td>
                `;
                tbody.appendChild(row);
            });
        }

        let sortColumn = 0; // Track the column being sorted

        function quickSort(arr, left, right, sortColumn) {
            if (left < right) { // Ensure that the left index is less than the right index
                const pivotIndex = partition(arr, left, right, sortColumn);
                quickSort(arr, left, pivotIndex - 1, sortColumn);  // Sort the left part
                quickSort(arr, pivotIndex + 1, right, sortColumn); // Sort the right part
            }
        }

        function partition(arr, left, right, sortColumn) {
            const pivot = arr[right]; // Select the last element as pivot
            let i = left - 1; // Index for the smaller element

            for (let j = left; j < right; j++) {
                if (compareRows(arr[j], pivot, sortColumn)) {
                    i++;
                    [arr[i], arr[j]] = [arr[j], arr[i]];  // Swap elements
                }
            }

            // Swap pivot with the element at i + 1
            [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]]; 

            return i + 1; // Return the pivot index
        }

        function compareRows(rowA, rowB, column) {
            if (column === 0) {
                return rowA[0] <= rowB[0];  // Column 0: index
            } else if (column === 1) {
                return rowA[1] <= rowB[1];  // Column 1: random integer
            } else {
                return rowA[2].localeCompare(rowB[2]) <= 0;  // Column 2: color combination (lexicographical comparison)
            }
        }

        function quickSortWithWorkers(rows) {
            const numWorkers = 4;
            const workerPromises = [];
            const chunkSize = Math.ceil(rows.length / numWorkers);

            const startTime = performance.now();

            // Split rows into chunks
            for (let i = 0; i < numWorkers; i++) {
                const start = i * chunkSize;
                const end = Math.min((i + 1) * chunkSize, rows.length);
                const chunk = rows.slice(start, end);
                
                const worker = new Worker('worker.js'); // Create the worker from an external file

                workerPromises.push(new Promise((resolve, reject) => {
                    worker.onmessage = function(e) {
                        resolve(e.data);
                    };
                    worker.onerror = reject;
                    worker.postMessage({ rows: chunk, sortColumn: sortColumn });
                }));
            }

            // Wait for all workers to finish
            Promise.all(workerPromises).then(sortedChunks => {
                // Merge sorted chunks (simplified merge for this case)
                const sortedRows = sortedChunks.flat();
                if (sortDirection[sortColumn] === -1) sortedRows.reverse();

                masterData = sortedRows; // Update masterData with the sorted rows
                renderTable(); // Re-render the table with sorted rows

                // Update sorting time
                const endTime = performance.now();
                const duration = (endTime - startTime).toFixed(2);
                document.getElementById("sortTime").textContent = `Sort Time: ${duration} ms`;
            });
        }

        function sortTable(columnIndex) {
            sortColumn = columnIndex; // Update the global sorting column index
            const algorithm = document.getElementById("sortAlgorithm").value;

            // Start timer
            const startTime = performance.now();

            if (algorithm === "js") {
                masterData.sort((rowA, rowB) => {
                    return (rowA[columnIndex] - rowB[columnIndex]) * sortDirection[columnIndex];
                });
            } else if (algorithm === "quick") {
                quickSort(masterData, 0, masterData.length - 1, sortColumn); // Now calling quickSort with left and right indices
                if (sortDirection[columnIndex] === -1) masterData.reverse();
            } else if (algorithm === "worker") {
                quickSortWithWorkers(masterData);
                return; // Don't proceed with normal sort if using workers
            }

            // Update sorting time
            const endTime = performance.now();
            const duration = (endTime - startTime).toFixed(2);
            document.getElementById("sortTime").textContent = `Sort Time: ${duration} ms`;

            // Reverse sorting direction for next click
            sortDirection[columnIndex] *= -1;

            // Re-render the table with sorted rows
            renderTable();
        }

        populateMasterData(); // Initially populate and render the table
    </script>
</body>
</html>
