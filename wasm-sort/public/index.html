<!DOCTYPE html>
<html lang="en">
<head>
    <title>Sortable Table with Web Workers</title>
</head>
<body>
    <div class="controls">
        <label for="sortAlgorithm">Choose Sorting Algorithm:</label>
        <select id="sortAlgorithm">
            <option value="js">JavaScript Sort</option>
            <option value="quick">Quick Sort</option>
            <option value="worker">Quick Sort with Web Workers</option>
        </select>
    </div>
    <div class="timing" id="sortTime">Sort Time: -</div>
    <table>
        <thead>
            <tr>
                <th onclick="sortTable(0)">Index ðŸ”½</th>
                <th onclick="sortTable(1)">Random Safe Integer ðŸ”½</th>
                <th>Color Combination</th>
            </tr>
        </thead>
        <tbody id="table-body"></tbody>
    </table>

    <script>
        const cssColors = [
            "red", "blue", "green", "yellow", "purple", "orange", "pink", "brown",
            "gray", "black", "white", "cyan", "magenta", "lime", "maroon", "navy",
            "olive", "teal", "silver", "gold", "coral", "violet", "indigo", "turquoise"
        ];

        let sortDirection = [1, 1]; // Stores sorting order (1 for ascending, -1 for descending)
        let masterData = []; // Holds the table data

        function getRandomSafeInteger() {
            return Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
        }

        function getRandomColorCombination() {
            const shuffled = cssColors.sort(() => Math.random() - 0.5);
            return shuffled.slice(0, 4).join(" ");
        }

        function populateMasterData() {
            masterData = [];
            for (let i = 1; i <= 1000; i++) {
                masterData.push([
                    i,
                    getRandomSafeInteger(),
                    getRandomColorCombination()
                ]);
            }
            renderTable(); // After populating the data, render the table
        }

        function renderTable() {
            const tbody = document.getElementById("table-body");
            tbody.innerHTML = ""; // Clear existing rows

            for (const [idx, value] of masterData.entries()) {
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${value[0]}</td>
                    <td>${value[1]}</td>
                    <td>${value[2]}</td>
                `;
                tbody.appendChild(row);

                if (idx === 999) { // only show first 1000 rows
                    break;
                }
            }
        }

        let sortColumn = 0; // Track the column being sorted

        function quickSort(arr, left, right, sortColumn) {
            if (left < right) { // Ensure that the left index is less than the right index
                const pivotIndex = partition(arr, left, right, sortColumn);
                quickSort(arr, left, pivotIndex - 1, sortColumn);  // Sort the left part
                quickSort(arr, pivotIndex + 1, right, sortColumn); // Sort the right part
            }
        }

        function partition(arr, left, right, sortColumn) {
            const pivot = arr[right]; // Select the last element as pivot
            let i = left - 1; // Index for the smaller element

            for (let j = left; j < right; j++) {
                if (compareRows(arr[j], pivot, sortColumn)) {
                    i++;
                    [arr[i], arr[j]] = [arr[j], arr[i]];  // Swap elements
                }
            }

            // Swap pivot with the element at i + 1
            [arr[i + 1], arr[right]] = [arr[right], arr[i + 1]]; 

            return i + 1; // Return the pivot index
        }

        function compareRows(rowA, rowB, column) {
            if (column === 0) {
                return rowA[0] <= rowB[0];  // Column 0: index
            } else if (column === 1) {
                return rowA[1] <= rowB[1];  // Column 1: random integer
            } else {
                return rowA[2].localeCompare(rowB[2]) <= 0;  // Column 2: color combination (lexicographical comparison)
            }
        }

        function sortTable(columnIndex) {
            sortColumn = columnIndex; // Update the global sorting column index
            const algorithm = document.getElementById("sortAlgorithm").value;

            const startTime = performance.now();

            if (algorithm === "js") {
                masterData.sort((rowA, rowB) => {
                    return (rowA[columnIndex] - rowB[columnIndex]) * sortDirection[columnIndex];
                });
            } else if (algorithm === "quick") {
                quickSort(masterData, 0, masterData.length - 1, sortColumn); // Now calling quickSort with left and right indices
                if (sortDirection[columnIndex] === -1) masterData.reverse();
            } else if (algorithm === "worker") {
                const chunks = 4;
                const size = Math.ceil(masterData.length / chunks);
                const workers = [];
                const promises = [];

                for (let i = 0; i < chunks; i++) {
                    const start = i * size;
                    const end = start + size;
                    const chunk = masterData.slice(start, end);

                    workers[i] = new Worker("worker.js");
                    promises.push(new Promise((resolve) => {
                        workers[i].onmessage = (e) => resolve(e.data);
                        workers[i].postMessage({ data: chunk, sortColumn });
                    }));
                }

                Promise.all(promises).then((sortedChunks) => {
                    masterData = sortedChunks.flat();

                    masterData.sort((a, b) => {
                        if (sortColumn === 0) return (a[0] - b[0]) * sortDirection[sortColumn];
                        if (sortColumn === 1) return (a[1] - b[1]) * sortDirection[sortColumn];
                        return a[2].localeCompare(b[2]) * sortDirection[sortColumn];
                    });

                    sortDirection[columnIndex] *= -1;

                    const endTime = performance.now();
                    const duration = (endTime - startTime).toFixed(2);
                    document.getElementById("sortTime").textContent = `Sort Time: ${duration} ms`;

                    renderTable();
                });

                return; // Skip the sortDirection toggle below until the promise resolves
            }


            // Reverse sorting direction for next click
            sortDirection[columnIndex] *= -1;

            const endTime = performance.now();
            const duration = (endTime - startTime).toFixed(2);
            document.getElementById("sortTime").textContent = `Sort Time: ${duration} ms`;

            // Re-render the table with sorted rows
            renderTable();
        }

        populateMasterData(); // Initially populate and render the table
    </script>
</body>
</html>
